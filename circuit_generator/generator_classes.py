
# coding: utf-8

# In[ ]:


dy[0]=0
dy[1]=R['J23100']-(dm+mu)*y[1]
dy[2]=B['10000']*y[1]-(dp+mu)*y[2]


# In[1]:


#GFP example
p_con=Promoter(name="J23100", dGRNAP=-4, rmax=2.8)
RBS1=RibosomeBindingSite(TIR=10000, sequence='TTATATTAGGAGGTCTC',dG_total=-4.0)
GFP=Protein_Coding_Sequence(name='GFP',nt_seq='ATG...')
ECK101=Terminator(name='ECK101'TE=0.95, seqeunce="AAAGAAUUU")
O1=Construct(p_con,RBS1,GFP,ECK101)
    Operon(Construct)
    EukaryoticGene(Construct)
AH3=Plasmid(ColEI, KanR, Operon) # autogenerated O kan R
if plasmid:
    geneticSystem=Organism(strain="EcMG1655",Plasmid)
if genome:
    g1=Genome(strain='')
    g1.integrate(S1,O1,pos=[begin,end],chrom='')
    geneticSystem=Organism(genome=g1,Plasmid)


# In[5]:


class Promoter(object):
    def __init__(self, name="", dG_RNAP=0.0, r_max=0.0):
        pass

class RBS(object):
    def __init__(self, name="", TIR=0.0, sequence="", dG_total=0.0):
        pass
    
class CDS(object):
    def __init__(self, name="GFP", sequence=""):
        pass
    
class Terminator(object):
    def __init__(self, name='', strength=0.0, efficiency=0.0, sequence="" ):
        pass
    
class Spacer(object):
    def __init__(self,sequence=""):
        pass

class Construct(object):
    def __init__(self,**kwargs):
        pass
    
class Operon(Construct):
    def dummy_fxn():
        pass
    
class EukaryoticGenome(Construct):
    def dummy_fxn():
        pass

class Plasmid(object):
    def __init__(self,**kwargs):
        pass

class Organism(object):
    def __init__(self,**kwargs):
        pass
    
class Chromosome(object):
    def __init__(self,**kwargs):
        pass
    
class transcription_models(object):
    def __init__():
        if "partition_fxn":
            pass
        if "hill_function":
            pass
    def Partition_fxn(a_max,dG_RNAP,N_RNAP,dG_Active,dG_Inactive, 
                  cooperativity,N_Repressors,fractionActive,genome_len,T):
        RT=T*1.987/1000 #temperature(kelvin)*R(kcal/K/mol)
    
        P_RNAP=(N_RNAP*math.exp(-dG_RNAP/RT)/genome_len)
        P_Active=N_Repressors * fractionActive * math.exp(- ((dG_Active)/RT)) / genome_len
        P_Inactive=N_Repressors * (1 - fractionActive) * math.exp(-((dG_Inactive)/RT)) / genome_len
    
        if cooperativity>1:
            Pbound=P_RNAP / (1 + P_RNAP + cooperativity*(P_Active + P_Inactive)+(P_Active + P_Inactive)**cooperativity)
        else:
            Pbound=P_RNAP / (1 + P_RNAP + (P_Active + P_Inactive))
        alpha=a_max*Pbound
        return alpha

    def Hill_function_R(a_max,Kd,cooperativity,N_Repressor):
        alpha = a_max/(1 + (N_Repressor/Kd)**cooperativity);
        return alpha

    def Hill_function_A(a_max,Ka,cooperativity,N_Activator):
        alpha = a_max*((N_Activator)**cooperativity)/(Ka**cooperativity + (N_Repressor)**cooperativity);
        return alpha    


# In[ ]:


#each construct class enumerates part types
# paired promoters produce 2 mRNAs
# terminators end that enumerated part

#nucleotide resolution flag
#
#dm11/dt=-rinit -dm1*m11
#dm12/dt=(1-Pfalloff)^2*relong*m12-dm2*m12


# In[ ]:


modelGen=ModelGenerator(geneticSystem)
listofModels=modelGen.generateModels(...)
for model in <possible combinations of fxns> #different models
    for part in Operon: # one model
        if part is Promoter():
            -new mRNA
            -select a function (depends on model)

